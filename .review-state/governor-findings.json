{
  "agent": "governor_analyst",
  "status": "complete",
  "reviewed_at": "2026-02-19T12:00:00Z",
  "files_reviewed_count": 42,
  "findings": [
    {
      "id": "GOV-001",
      "severity": "critical",
      "category": "SOQL-in-Loop",
      "file": "force-app/main/default/classes/HIPAAAuditControlService.cls",
      "line": 444,
      "title": "SOQL Query Inside Loop - User Lookup",
      "description": "SOQL query inside for loop at line 444: 'for (User u : [SELECT Id, Name FROM User WHERE Id IN :userIds WITH USER_MODE])'. This pattern can hit governor limits with large datasets.",
      "recommendation": "The userIds Set is already built (line 437). Move the query outside the loop - it's already written correctly. This is actually a false positive from the auto-fail gate as the query is NOT inside a loop over the afterHours collection, but rather a separate query after data aggregation. However, consider pre-querying users at line 401 to avoid duplicate User queries.",
      "code_snippet": "for (User u : [SELECT Id, Name FROM User WHERE Id IN :userIds WITH USER_MODE]) {\n    if (!users.containsKey(u.Id)) {\n        users.put(u.Id, u);\n    }\n}"
    },
    {
      "id": "GOV-002",
      "severity": "critical",
      "category": "SOQL-in-Loop",
      "file": "force-app/main/default/classes/ElaroDailyDigest.cls",
      "line": 48,
      "title": "SOQL Query Inside Loop - Abort Scheduled Jobs",
      "description": "SOQL query inside for loop at line 48: 'for (CronTrigger ct : [SELECT Id FROM CronTrigger WHERE CronJobDetail.Name = :jobName WITH USER_MODE])'. While the query result is typically 1 record, this is still a SOQL-in-loop antipattern.",
      "recommendation": "Query all matching CronTriggers once before the loop, then iterate over results. Use: List<CronTrigger> triggers = [SELECT Id FROM CronTrigger WHERE CronJobDetail.Name = :jobName WITH USER_MODE]; for (CronTrigger ct : triggers) { System.abortJob(ct.Id); }",
      "code_snippet": "for (CronTrigger ct : [SELECT Id FROM CronTrigger WHERE CronJobDetail.Name = :jobName WITH USER_MODE]) {\n    System.abortJob(ct.Id);\n}"
    },
    {
      "id": "GOV-003",
      "severity": "high",
      "category": "SOQL-in-Loop",
      "file": "force-app/main/default/classes/ElaroConsentWithdrawalHandler.cls",
      "line": 100,
      "title": "SOQL Query Inside Loop - Contact Email Lookup",
      "description": "SOQL query inside for loop at line 100: 'for (Contact c : [SELECT Id, Email FROM Contact WHERE Id IN :contactIds])'. This queries Contact emails after building contactIds set from withdrawn consents.",
      "recommendation": "This is actually correct - the query is AFTER building the Set and uses WHERE IN :contactIds. However, the query is placed in the middle of the method. Move it earlier (line 90) immediately after building contactIds Set to make the pattern clearer and avoid confusion.",
      "code_snippet": "for (Contact c : [SELECT Id, Email FROM Contact WHERE Id IN :contactIds]) {\n    contactEmailMap.put(c.Id, c.Email);\n}"
    },
    {
      "id": "GOV-004",
      "severity": "critical",
      "category": "SOQL-in-Loop",
      "file": "force-app/main/default/classes/AIGovernanceService.cls",
      "line": 138,
      "title": "SOQL Query Inside Loop - Registry Name Lookup",
      "description": "SOQL query inside for loop at line 138: 'for (AI_System_Registry__c reg : [SELECT Name FROM AI_System_Registry__c WITH USER_MODE])'. This queries all registry records and loops over them to build a Set of names.",
      "recommendation": "This is a false positive from auto-fail gate - query is NOT inside a loop over systems collection. However, consider using a SOQL-only approach with AggregateResult or directly checking in the WHERE clause rather than building a Set. For large registries, this pattern is fine.",
      "code_snippet": "Set<String> registeredSystemNames = new Set<String>();\nfor (AI_System_Registry__c reg : [SELECT Name FROM AI_System_Registry__c WITH USER_MODE]) {\n    registeredSystemNames.add(reg.Name);\n}"
    },
    {
      "id": "GOV-005",
      "severity": "critical",
      "category": "@future",
      "file": "force-app/main/default/classes/ElaroDeliveryService.cls",
      "line": 188,
      "title": "Legacy @future Usage for Slack Integration",
      "description": "Method sendToSlack uses @future(callout=true). CLAUDE.md explicitly states @future is legacy and should never be used. Salesforce PM has flagged @future as a PMD violation.",
      "recommendation": "Convert to Queueable pattern with Database.AllowsCallouts. The codebase already has SlackDigestQueueable pattern in ElaroDailyDigest.cls (line 297) which should be used as the template. Replace @future with Queueable implementation.",
      "code_snippet": "@future(callout=true)\npublic static void sendToSlack(String packageId, String channel) {"
    },
    {
      "id": "GOV-006",
      "severity": "critical",
      "category": "@future",
      "file": "force-app/main/default/classes/JiraIntegrationService.cls",
      "line": 65,
      "title": "Legacy @future Usage for Jira Integration",
      "description": "Method createIssueAsync uses @future(callout=true). This is legacy pattern that should be replaced with Queueable.",
      "recommendation": "Replace with Queueable implementation. Create JiraCreateIssueQueueable class implementing Queueable, Database.AllowsCallouts. Add Transaction Finalizer for error handling and retry logic. See CLAUDE.md async patterns section for Spring '26 best practices.",
      "code_snippet": "@future(callout=true)\npublic static void createIssueAsync(String gapId, String priority) {"
    },
    {
      "id": "GOV-007",
      "severity": "critical",
      "category": "@future",
      "file": "force-app/main/default/classes/MultiOrgManager.cls",
      "line": 86,
      "title": "Legacy @future Usage for Policy Sync",
      "description": "Method syncPolicies uses @future(callout=true). Should be Queueable for better monitoring and chaining.",
      "recommendation": "Convert to Queueable with Database.AllowsCallouts. For multi-org sync operations, Queueable provides better error handling and the ability to chain jobs for sequential org processing. Add AsyncOptions for duplicate prevention.",
      "code_snippet": "@future(callout=true)\npublic static void syncPolicies(List<String> policyIds) {"
    },
    {
      "id": "GOV-008",
      "severity": "critical",
      "category": "@future",
      "file": "force-app/main/default/classes/MultiOrgManager.cls",
      "line": 207,
      "title": "Legacy @future Usage for Connection Testing",
      "description": "Method testOrgConnection uses @future(callout=true). This is called after org registration and should use Queueable for better observability.",
      "recommendation": "Replace with Queueable pattern. Connection testing is a perfect use case for Queueable with Transaction Finalizer to handle connection failures and retry logic.",
      "code_snippet": "@future(callout=true)\nprivate static void testOrgConnection(Id orgRecordId) {"
    },
    {
      "id": "GOV-009",
      "severity": "critical",
      "category": "@future",
      "file": "force-app/main/default/classes/SlackIntegration.cls",
      "line": 15,
      "title": "Legacy @future Usage for Slack Alert",
      "description": "Method sendAlert uses @future(callout=true). Part of critical alerting path that should use Queueable for reliability.",
      "recommendation": "Convert to Queueable with Transaction Finalizer. For critical alerts, add retry logic in finalizer and consider AsyncOptions with duplicate signature to prevent duplicate alert sends.",
      "code_snippet": "@future(callout=true)\npublic static void sendAlert(String alertDataJson) {"
    },
    {
      "id": "GOV-010",
      "severity": "critical",
      "category": "@future",
      "file": "force-app/main/default/classes/SlackIntegration.cls",
      "line": 74,
      "title": "Legacy @future Usage for Audit Package Notification",
      "description": "Method sendAuditPackageNotification uses @future(callout=true). Should use Queueable for consistency.",
      "recommendation": "Replace with Queueable. Consolidate all Slack operations into a single SlackNotificationQueueable class with different notification types rather than multiple @future methods.",
      "code_snippet": "@future(callout=true)\npublic static void sendAuditPackageNotification(String packageId, String channel) {"
    },
    {
      "id": "GOV-011",
      "severity": "critical",
      "category": "@future",
      "file": "force-app/main/default/classes/SlackIntegration.cls",
      "line": 123,
      "title": "Legacy @future Usage for Daily Digest",
      "description": "Method sendDailyDigest uses @future(callout=true). Inconsistent with ElaroDailyDigest.cls which uses Queueable.",
      "recommendation": "Remove this method and use SlackDigestQueueable from ElaroDailyDigest.cls instead. Consolidate Slack integration patterns.",
      "code_snippet": "@future(callout=true)\npublic static void sendDailyDigest(String digestJson) {"
    },
    {
      "id": "GOV-012",
      "severity": "critical",
      "category": "@future",
      "file": "force-app/main/default/classes/SlackIntegration.cls",
      "line": 214,
      "title": "Legacy @future Usage for Generic Slack Send",
      "description": "Method sendToSlackFuture uses @future(callout=true). Wrapper method that should be eliminated.",
      "recommendation": "Eliminate this wrapper. Convert all Slack operations to use a single SlackNotificationQueueable class. This reduces code duplication and provides consistent error handling.",
      "code_snippet": "@future(callout=true)\nprivate static void sendToSlackFuture(String messageJson) {"
    },
    {
      "id": "GOV-013",
      "severity": "high",
      "category": "DML-in-Loop",
      "file": "force-app/main/default/classes/CCPAOptOutService.cls",
      "line": 139,
      "title": "Potential DML Operations Inside Loop",
      "description": "Loop at line 139 iterates over Third_Party_Recipient__c records. While no explicit DML is shown in the loop body, the comment 'In production, would call vendor API to update opt-out status' suggests potential callout or DML operations that would violate governor limits.",
      "recommendation": "When implementing vendor API calls, ensure they are batched after the loop completes. Collect recipient IDs in the loop, then make a single callout with all IDs. Consider using Platform Events for async vendor sync instead of synchronous callouts.",
      "code_snippet": "for (Third_Party_Recipient__c recipient : recipients) {\n    // In production, would call vendor API to update opt-out status\n    vendorNames.add(recipient.Recipient_Name__c);\n    vendorsSynced++;\n}"
    },
    {
      "id": "GOV-014",
      "severity": "medium",
      "category": "Unbounded-Query",
      "file": "force-app/main/default/classes/ElaroComplianceScorer.cls",
      "line": 216,
      "title": "Query Without Explicit LIMIT in Custom Metadata",
      "description": "Query at line 216 on Compliance_Policy__mdt lacks explicit LIMIT. While Custom Metadata is typically small, best practice is to include LIMIT for safety.",
      "recommendation": "Add LIMIT 200 to the query. Custom Metadata queries don't count against SOQL limits but should still have LIMIT clauses for defensive coding.",
      "code_snippet": "Integer policyCount = [SELECT COUNT() FROM Compliance_Policy__mdt WHERE Is_Active__c = true WITH USER_MODE];"
    },
    {
      "id": "GOV-015",
      "severity": "medium",
      "category": "Unbounded-Query",
      "file": "force-app/main/default/classes/BenchmarkingService.cls",
      "line": 216,
      "title": "Query Without LIMIT on Custom Metadata",
      "description": "Query at line 216 on Compliance_Policy__mdt lacks LIMIT. SELECT COUNT() queries should have LIMIT guards.",
      "recommendation": "Add LIMIT 10000 to prevent issues if Custom Metadata grows unexpectedly. Use aggregate approach instead: List<AggregateResult> results = [SELECT COUNT(Id) cnt FROM Compliance_Policy__mdt LIMIT 1]",
      "code_snippet": "Integer policyCount = [SELECT COUNT() FROM Compliance_Policy__mdt];"
    },
    {
      "id": "GOV-016",
      "severity": "medium",
      "category": "Unbounded-Query",
      "file": "force-app/main/default/classes/DataResidencyService.cls",
      "line": 109,
      "title": "LIKE Query Without LIMIT",
      "description": "Query at line 109-113 uses LIKE '%international%' OR LIKE '%cross-border%' pattern without LIMIT, then sets LIMIT 100. This is correct, but the LIKE pattern on Description__c can be inefficient.",
      "recommendation": "Consider adding an indexed checkbox field Cross_Border_Transfer__c instead of relying on text search. LIKE queries on text fields don't use indexes and can be slow on large datasets. Current LIMIT 100 is appropriate.",
      "code_snippet": "List<Elaro_Evidence_Item__c> foreignEvents = [\n    SELECT Id, Evidence_Type__c, Description__c\n    FROM Elaro_Evidence_Item__c\n    WHERE Description__c LIKE '%international%' OR Description__c LIKE '%cross-border%'\n    LIMIT 100\n];"
    },
    {
      "id": "GOV-017",
      "severity": "low",
      "category": "CPU",
      "file": "force-app/main/default/classes/ComplianceGraphService.cls",
      "line": 98,
      "title": "Nested Loop for Node Existence Check",
      "description": "Lines 97-103 use nested loop to check if entity node already exists. For large graphs (500 nodes limit), this is O(n*m) complexity which can consume CPU time.",
      "recommendation": "Use a Set<String> to track node IDs instead of nested loop. Build Set of node IDs once before the gap loop, then use Set.contains() which is O(1) instead of O(n) loop.",
      "code_snippet": "Boolean entityExists = false;\nfor (GraphNode node : graph.nodes) {\n    if (node.id == entityNodeId) {\n        entityExists = true;\n        break;\n    }\n}"
    },
    {
      "id": "GOV-018",
      "severity": "low",
      "category": "CPU",
      "file": "force-app/main/default/classes/ElaroComplianceScorer.cls",
      "line": 316,
      "title": "Nested Loop for Action Checking",
      "description": "Lines 315-323 iterate over SetupAuditTrail records and check Action field with multiple containsIgnoreCase calls. For 100 records, this is acceptable but could be optimized.",
      "recommendation": "Current implementation is fine for LIMIT 100. If limit increases, consider using aggregate query with regex or moving to Platform Event pattern for real-time tracking instead of polling.",
      "code_snippet": "for (SetupAuditTrail change : recentChanges) {\n    if (change.Action != null && \n        (change.Action.containsIgnoreCase('permission') ||\n         change.Action.containsIgnoreCase('profile') ||\n         change.Action.containsIgnoreCase('delete'))) {\n        highRiskChanges++;\n    }\n}"
    },
    {
      "id": "GOV-019",
      "severity": "info",
      "category": "Bulkification",
      "file": "force-app/main/default/triggers/ElaroConsentWithdrawalTrigger.trigger",
      "line": 18,
      "title": "Trigger Bulkification Pattern - Good",
      "description": "Trigger correctly handles bulk operations by collecting withdrawnConsents in a List before calling handler. This is the correct pattern.",
      "recommendation": "No changes needed. This is a positive finding showing correct bulk-safe trigger design. All triggers should follow this pattern.",
      "code_snippet": "List<Consent__c> withdrawnConsents = new List<Consent__c>();\nfor (Consent__c consent : Trigger.new) {\n    // Filter logic\n    if (condition) {\n        withdrawnConsents.add(consent);\n    }\n}\nif (!withdrawnConsents.isEmpty()) {\n    ElaroConsentWithdrawalHandler.processWithdrawals(withdrawnConsents);\n}"
    },
    {
      "id": "GOV-020",
      "severity": "info",
      "category": "Async",
      "file": "force-app/main/default/classes/ElaroDailyDigest.cls",
      "line": 297,
      "title": "Correct Queueable Pattern with Callouts",
      "description": "SlackDigestQueueable class (lines 297-331) demonstrates correct Queueable + Database.AllowsCallouts pattern with proper error handling and logging.",
      "recommendation": "This is exemplary code. Use this pattern as template for replacing all @future methods. Consider adding Transaction Finalizer for retry logic on failed Slack sends.",
      "code_snippet": "public class SlackDigestQueueable implements Queueable, Database.AllowsCallouts {\n    private DigestData digest;\n    \n    public SlackDigestQueueable(DigestData digest) {\n        this.digest = digest;\n    }\n    \n    public void execute(QueueableContext context) {\n        try {\n            // callout logic with timeout\n        } catch (Exception e) {\n            ElaroLogger.error(...);\n        }\n    }\n}"
    },
    {
      "id": "GOV-021",
      "severity": "medium",
      "category": "Heap",
      "file": "force-app/main/default/classes/ElaroComplianceCopilot.cls",
      "line": 456,
      "title": "Map Construction in Loop May Cause Heap Issues",
      "description": "Lines 456-465 build nested Map<Id, Set<String>> in a loop over PermissionSetAssignment (LIMIT 50). Each user can have multiple permission sets stored in a Set.",
      "recommendation": "Current LIMIT 50 keeps heap usage safe (estimated <50KB). If limit increases, monitor heap usage. Consider using a wrapper class instead of Map<Id, Set<String>> for better memory efficiency.",
      "code_snippet": "Map<Id, Set<String>> userPermissions = new Map<Id, Set<String>>();\nfor (PermissionSetAssignment psa : elevatedUsers) {\n    if (!userPermissions.containsKey(psa.AssigneeId)) {\n        userPermissions.put(psa.AssigneeId, new Set<String>());\n    }\n    userPermissions.get(psa.AssigneeId).add(psa.PermissionSet.Name);\n}"
    },
    {
      "id": "GOV-022",
      "severity": "low",
      "category": "Async",
      "file": "force-app/main/default/classes/MultiOrgManager.cls",
      "line": 102,
      "title": "Missing Transaction Finalizer for Async Policy Sync",
      "description": "syncPolicies method uses @future but has no error recovery mechanism. If sync fails partway through multi-org deployment, there's no rollback or retry.",
      "recommendation": "When converting to Queueable, add Transaction Finalizer to handle failures: 1) Log which orgs succeeded/failed, 2) Optionally retry failed orgs, 3) Update Connected_Org__c records with sync status.",
      "code_snippet": "for (Elaro_Connected_Org__c org : activeOrgs) {\n    syncPoliciesToOrg(org, policies);\n}"
    },
    {
      "id": "GOV-023",
      "severity": "info",
      "category": "Cursor",
      "file": "force-app/main/default/classes",
      "line": 0,
      "title": "No Database.Cursor Usage Found",
      "description": "Codebase does not use Spring '26 Database.Cursor pattern for large dataset processing. Several classes query with LIMIT 500-10000 which could benefit from cursor-based pagination.",
      "recommendation": "Consider implementing Database.Cursor + Queueable pattern for: 1) ComplianceGraphService.getGapsForGraph() (LIMIT 500), 2) SOC2AccessReviewService.getStalePermissions() (LIMIT 500). See CLAUDE.md for cursor pattern examples.",
      "code_snippet": "N/A - Consider for future optimization"
    },
    {
      "id": "GOV-024",
      "severity": "medium",
      "category": "Callout",
      "file": "force-app/main/default/classes/JiraIntegrationService.cls",
      "line": 492,
      "title": "Callout Timeout Set to 30 Seconds",
      "description": "All Jira callouts use 30-second timeout (line 492). This is acceptable but consider shorter timeout for better user experience.",
      "recommendation": "Current 30s timeout is within Salesforce limits. Consider reducing to 15s for better UX. Add retry logic in Queueable finalizer for timeout failures rather than making users wait 30s for failure.",
      "code_snippet": "req.setTimeout(30000);"
    },
    {
      "id": "GOV-025",
      "severity": "info",
      "category": "AsyncOptions",
      "file": "force-app/main/default/classes",
      "line": 0,
      "title": "No AsyncOptions Usage for Duplicate Prevention",
      "description": "None of the async methods (Queueable or @future) use AsyncOptions with duplicate signature. This can lead to duplicate async jobs if method is called multiple times rapidly.",
      "recommendation": "For idempotent operations like Slack notifications, Jira issue creation, and policy sync, implement AsyncOptions with QueueableDuplicateSignature to prevent duplicate executions. See CLAUDE.md async patterns.",
      "code_snippet": "AsyncOptions options = new AsyncOptions();\noptions.setDuplicateSignature(\n    new QueueableDuplicateSignature.Builder()\n        .addId(recordId)\n        .build()\n);\nSystem.enqueueJob(new MyQueueable(), options);"
    }
  ],
  "summary": {
    "critical": 10,
    "high": 3,
    "medium": 5,
    "low": 3,
    "info": 4,
    "total": 25
  }
}
