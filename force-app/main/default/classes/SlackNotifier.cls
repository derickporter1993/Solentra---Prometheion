public with sharing class SlackNotifier {
    /**
     * @deprecated Use notifyAsyncQueueable instead for better error handling and retry logic
     */
    @future(callout=true)
    @Deprecated
    public static void notifyAsync(String text) {
        // Maintain backward compatibility, delegate to Queueable
        notifyAsyncQueueable(text);
    }

    /**
     * Send Slack notification using Queueable (recommended approach)
     * Provides retry logic, error handling, and better monitoring
     */
    public static void notifyAsyncQueueable(String text) {
        if (String.isBlank(text)) {
            System.debug(LoggingLevel.WARN, 'SlackNotifier: Empty text provided, skipping notification');
            return;
        }

        try {
            Map<String, Object> payload = new Map<String, Object>{ 'text' => text };
            String jsonPayload = JSON.serialize(payload);
            String correlationId = 'TEXT-' + System.now().getTime() + '-' + Crypto.getRandomInteger();

            PrometheionSlackNotifierQueueable job = new PrometheionSlackNotifierQueueable(jsonPayload, correlationId);
            System.enqueueJob(job);
        } catch (Exception e) {
            String correlationId = 'TEXT-ERROR-' + System.now().getTime();
            logIntegrationError('SLACK', 'Failed to enqueue notification', e.getMessage(), e.getStackTraceString(), correlationId, text);
            System.debug(LoggingLevel.ERROR, 'SlackNotifier: Failed to enqueue notification. CorrelationId: ' + correlationId + ', Error: ' + e.getMessage());
        }
    }

    /**
     * @deprecated Use notifyRichAsyncQueueable instead for better error handling and retry logic
     */
    @future(callout=true)
    @Deprecated
    public static void notifyRichAsync(String jsonPayload) {
        // Maintain backward compatibility, delegate to Queueable
        notifyRichAsyncQueueable(jsonPayload);
    }

    /**
     * Send rich Slack notification using Queueable (recommended approach)
     * Provides retry logic, payload validation, and better error handling
     */
    public static void notifyRichAsyncQueueable(String jsonPayload) {
        if (String.isBlank(jsonPayload)) {
            System.debug(LoggingLevel.WARN, 'SlackNotifier: Empty payload provided, skipping notification');
            return;
        }

        try {
            // Validate JSON format
            JSON.deserializeUntyped(jsonPayload);

            String correlationId = 'RICH-' + System.now().getTime() + '-' + Crypto.getRandomInteger();
            PrometheionSlackNotifierQueueable job = new PrometheionSlackNotifierQueueable(jsonPayload, correlationId);
            System.enqueueJob(job);
        } catch (JSONException e) {
            String correlationId = 'RICH-ERROR-' + System.now().getTime();
            logIntegrationError('SLACK', 'Invalid JSON payload', e.getMessage(), e.getStackTraceString(), correlationId, jsonPayload);
            System.debug(LoggingLevel.ERROR, 'SlackNotifier: Invalid JSON payload. CorrelationId: ' + correlationId + ', Error: ' + e.getMessage());
        } catch (Exception e) {
            String correlationId = 'RICH-ERROR-' + System.now().getTime();
            logIntegrationError('SLACK', 'Failed to enqueue rich notification', e.getMessage(), e.getStackTraceString(), correlationId, jsonPayload);
            System.debug(LoggingLevel.ERROR, 'SlackNotifier: Failed to enqueue rich notification. CorrelationId: ' + correlationId + ', Error: ' + e.getMessage());
        }
    }

    public static void notifyPerformanceEvent(Performance_Alert__e performanceEvent) {
        // Use rich formatting for performance alerts
        String jsonPayload = buildPerformanceAlertBlocks(performanceEvent);
        notifyRichAsyncQueueable(jsonPayload);
    }

    // Build Slack Block Kit JSON for performance alerts
    private static String buildPerformanceAlertBlocks(Performance_Alert__e performanceEvent) {
        // Determine severity emoji and color
        String emoji = '‚ö†Ô∏è';
        String color = '#ffb75d'; // Warning (orange)

        Decimal percentOfLimit = (performanceEvent.Value__c / performanceEvent.Threshold__c) * 100;

        if (percentOfLimit >= 95) {
            emoji = 'üî¥';
            color = '#c23934'; // Critical (red)
        } else if (percentOfLimit >= 90) {
            emoji = 'üü°';
            color = '#ffb75d'; // Warning (orange)
        }

        // Build the blocks structure
        Map<String, Object> payload = new Map<String, Object>();

        // Fallback text for notifications
        payload.put(
            'text',
            emoji +
            ' Prometheion Alert: ' +
            performanceEvent.Metric__c +
            ' at ' +
            percentOfLimit.setScale(1) +
            '%'
        );

        // Build rich blocks
        List<Map<String, Object>> blocks = new List<Map<String, Object>>();

        // Header block
        Map<String, Object> headerBlock = new Map<String, Object>();
        headerBlock.put('type', 'header');
        Map<String, Object> headerText = new Map<String, Object>();
        headerText.put('type', 'plain_text');
        headerText.put(
            'text',
            emoji +
            ' ' +
            performanceEvent.Metric__c +
            ' Performance Alert'
        );
        headerBlock.put('text', headerText);
        blocks.add(headerBlock);

        // Divider
        blocks.add(new Map<String, Object>{ 'type' => 'divider' });

        // Main info section
        Map<String, Object> infoSection = new Map<String, Object>();
        infoSection.put('type', 'section');
        List<Map<String, Object>> fields = new List<Map<String, Object>>();

        // Current Value
        Map<String, Object> valueField = new Map<String, Object>();
        valueField.put('type', 'mrkdwn');
        valueField.put(
            'text',
            '*Current Value:*\n' +
            String.valueOf(performanceEvent.Value__c.setScale(0)) +
            ' (' +
            percentOfLimit.setScale(1) +
            '%)'
        );
        fields.add(valueField);

        // Threshold
        Map<String, Object> thresholdField = new Map<String, Object>();
        thresholdField.put('type', 'mrkdwn');
        thresholdField.put(
            'text',
            '*Threshold:*\n' +
            String.valueOf(performanceEvent.Threshold__c.setScale(0))
        );
        fields.add(thresholdField);

        // Metric Type
        Map<String, Object> metricField = new Map<String, Object>();
        metricField.put('type', 'mrkdwn');
        metricField.put('text', '*Metric:*\n' + performanceEvent.Metric__c);
        fields.add(metricField);

        // Context Record (if available)
        if (!String.isBlank(performanceEvent.Context_Record__c)) {
            Map<String, Object> contextField = new Map<String, Object>();
            contextField.put('type', 'mrkdwn');
            contextField.put('text', '*Context:*\n' + performanceEvent.Context_Record__c);
            fields.add(contextField);
        }

        infoSection.put('fields', fields);
        blocks.add(infoSection);

        // Stack trace context (if available) - truncate to prevent Slack limits
        if (!String.isBlank(performanceEvent.Stack__c)) {
            // Slack has a 3000 character limit per block, truncate if needed
            String stackTrace = performanceEvent.Stack__c;
            Integer maxLength = 2500; // Leave room for markdown formatting
            if (stackTrace.length() > maxLength) {
                stackTrace = stackTrace.substring(0, maxLength) + '\n... (truncated)';
            }
            
            Map<String, Object> stackSection = new Map<String, Object>();
            stackSection.put('type', 'section');
            Map<String, Object> stackText = new Map<String, Object>();
            stackText.put('type', 'mrkdwn');
            stackText.put('text', '*Details:*\n```' + stackTrace + '```');
            stackSection.put('text', stackText);
            blocks.add(stackSection);
        }

        // Divider before actions
        blocks.add(new Map<String, Object>{ 'type' => 'divider' });

        // Action buttons (if Salesforce URL is available)
        String orgUrl = URL.getOrgDomainUrl().toExternalForm();
        Map<String, Object> actionsBlock = new Map<String, Object>();
        actionsBlock.put('type', 'actions');
        List<Map<String, Object>> elements = new List<Map<String, Object>>();

        // View Dashboard button
        Map<String, Object> dashboardButton = new Map<String, Object>();
        dashboardButton.put('type', 'button');
        Map<String, Object> dashboardText = new Map<String, Object>();
        dashboardText.put('type', 'plain_text');
        dashboardText.put('text', 'üìä View Dashboard');
        dashboardButton.put('text', dashboardText);
        dashboardButton.put('url', orgUrl + '/lightning/page/home');
        elements.add(dashboardButton);

        actionsBlock.put('elements', elements);
        blocks.add(actionsBlock);

        // Add blocks and attachments to payload
        payload.put('blocks', blocks);

        // Add attachment for color bar
        List<Map<String, Object>> attachments = new List<Map<String, Object>>();
        Map<String, Object> attachment = new Map<String, Object>();
        attachment.put('color', color);
        attachment.put(
            'footer',
            'Prometheion | ' +
            Datetime.now().format('yyyy-MM-dd HH:mm:ss')
        );
        attachments.add(attachment);
        payload.put('attachments', attachments);

        return JSON.serialize(payload);
    }

    // Build Slack notification for Flow performance issues
    public static void notifyFlowPerformance(
        String flowName,
        Decimal cpuTime,
        String rating,
        Decimal percentileRank
    ) {
        // Validate inputs
        if (String.isBlank(flowName)) {
            System.debug(LoggingLevel.WARN, 'SlackNotifier: Empty flowName provided, skipping notification');
            return;
        }
        if (cpuTime == null || cpuTime < 0) {
            System.debug(LoggingLevel.WARN, 'SlackNotifier: Invalid cpuTime provided, skipping notification');
            return;
        }
        if (String.isBlank(rating)) {
            rating = 'Unknown';
        }
        Map<String, Object> payload = new Map<String, Object>();

        String emoji = rating == 'Critical' ? 'üî¥' : rating == 'Slow' ? 'üü°' : '‚ÑπÔ∏è';

        payload.put('text', emoji + ' Flow Performance Alert: ' + flowName);

        List<Map<String, Object>> blocks = new List<Map<String, Object>>();

        // Header
        Map<String, Object> headerBlock = new Map<String, Object>();
        headerBlock.put('type', 'header');
        Map<String, Object> headerText = new Map<String, Object>();
        headerText.put('type', 'plain_text');
        headerText.put('text', emoji + ' Flow Performance: ' + flowName);
        headerBlock.put('text', headerText);
        blocks.add(headerBlock);

        blocks.add(new Map<String, Object>{ 'type' => 'divider' });

        // Info section
        Map<String, Object> infoSection = new Map<String, Object>();
        infoSection.put('type', 'section');
        List<Map<String, Object>> fields = new List<Map<String, Object>>();

        Map<String, Object> cpuField = new Map<String, Object>();
        cpuField.put('type', 'mrkdwn');
        cpuField.put('text', '*CPU Time:*\n' + cpuTime.setScale(0) + 'ms');
        fields.add(cpuField);

        Map<String, Object> ratingField = new Map<String, Object>();
        ratingField.put('type', 'mrkdwn');
        ratingField.put('text', '*Rating:*\n' + rating);
        fields.add(ratingField);

        if (percentileRank != null) {
            Map<String, Object> percentileField = new Map<String, Object>();
            percentileField.put('type', 'mrkdwn');
            percentileField.put(
                'text',
                '*Percentile:*\n' +
                percentileRank.setScale(1) +
                'th'
            );
            fields.add(percentileField);
        }

        infoSection.put('fields', fields);
        blocks.add(infoSection);

        payload.put('blocks', blocks);

        notifyRichAsyncQueueable(JSON.serialize(payload));
    }
    
    /**
     * Log integration errors to Integration_Error__c object for tracking and retry
     */
    private static void logIntegrationError(String errorType, String errorMessage, String stackTrace, String correlationId, String context) {
        logIntegrationError(errorType, errorMessage, stackTrace, correlationId, context, null);
    }
    
    private static void logIntegrationError(String errorType, String errorMessage, String stackTrace, String correlationId, String context, String additionalContext) {
        if (String.isBlank(errorMessage)) {
            errorMessage = 'Unknown error';
        }
        if (String.isBlank(stackTrace)) {
            stackTrace = '';
        }
        // TODO: Re-enable Integration_Error__c logging after creating object in org
        // try {
        //     Integration_Error__c error = new Integration_Error__c(
        //         Error_Type__c = errorType,
        //         Error_Message__c = errorMessage,
        //         Stack_Trace__c = stackTrace,
        //         Correlation_Id__c = correlationId,
        //         Context__c = additionalContext != null ? context + '\n\nAdditional Context: ' + additionalContext : context,
        //         Status__c = 'NEW',
        //         Timestamp__c = System.now()
        //     );
        //     insert error;
        // } catch (Exception e) {
        //     // Don't fail the main operation if error logging fails
        //     System.debug(LoggingLevel.ERROR, 'SlackNotifier: Failed to log integration error. Original error: ' + errorMessage + ', Logging error: ' + e.getMessage());
        // }
        System.debug(LoggingLevel.ERROR, 'SlackNotifier: Integration error logged. Type: ' + errorType + ', CorrelationId: ' + correlationId + ', Error: ' + errorMessage);
    }
}
