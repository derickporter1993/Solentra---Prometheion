/**
 * @description Schedulable class for daily compliance digest
 * Sends daily summary at 6 AM with statistics, top risks, and AI summary
 * @group Automation & Alerting
 * @author Elaro Team
 */
public with sharing class ElaroDailyDigest implements Schedulable {
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONSTANTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    private static final Integer DIGEST_LOOKBACK_HOURS = 24;
    private static final Integer MAX_TOP_RISKS = 10;
    private static final Integer QUERY_LIMIT = 10000;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCHEDULABLE INTERFACE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    /**
     * @description Execute scheduled job
     * @param sc SchedulableContext
     */
    public void execute(SchedulableContext sc) {
        generateAndSendDigest();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PUBLIC METHODS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    /**
     * @description Schedule the daily digest
     * @param cronExpression The cron expression (default: 6 AM daily)
     * @return Scheduled job ID
     */
    @AuraEnabled
    public static Id scheduleDigest(String cronExpression) {
        if (String.isBlank(cronExpression)) {
            // Default to 6 AM every day
            cronExpression = '0 0 6 * * ?';
        }
        
        String jobName = 'Elaro_Daily_Digest_' + UserInfo.getUserId();
        
        // Remove existing job if present
        for (CronTrigger ct : [SELECT Id FROM CronTrigger WHERE CronJobDetail.Name = :jobName WITH USER_MODE]) {
            System.abortJob(ct.Id);
        }
        
        return System.schedule(jobName, cronExpression, new ElaroDailyDigest());
    }
    
    /**
     * @description Generate and send digest immediately
     */
    @AuraEnabled
    public static void generateAndSendDigest() {
        DigestData digest = compileDigestData();
        sendDigestEmail(digest);
        sendDigestToSlack(digest);
    }
    
    /**
     * @description Get digest preview without sending
     * @return DigestData containing the digest content
     */
    @AuraEnabled(cacheable=true)
    public static DigestData getDigestPreview() {
        return compileDigestData();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PRIVATE METHODS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    /**
     * @description Compile all digest data
     * @return DigestData with all statistics and risks
     */
    private static DigestData compileDigestData() {
        DigestData digest = new DigestData();
        digest.generatedAt = Datetime.now();
        digest.periodStart = Datetime.now().addHours(-DIGEST_LOOKBACK_HOURS);
        digest.periodEnd = Datetime.now();
        
        // Get event statistics
        digest.statistics = getEventStatistics();
        
        // Get top risks
        digest.topRisks = getTopRisks();
        
        // Get compliance score
        digest.complianceScore = getComplianceScore();
        
        // Generate AI summary
        digest.aiSummary = generateAISummary(digest);
        
        // Get trending information
        digest.trendingUp = getTrendingItems('UP');
        digest.trendingDown = getTrendingItems('DOWN');
        
        return digest;
    }
    
    /**
     * @description Get event statistics for the digest period
     */
    private static EventStatistics getEventStatistics() {
        EventStatistics stats = new EventStatistics();
        Datetime cutoffTime = Datetime.now().addHours(-DIGEST_LOOKBACK_HOURS);
        
        // Query evidence items
        List<AggregateResult> results = [
            SELECT Evidence_Type__c eventType, COUNT(Id) cnt, Status__c status
            FROM Elaro_Evidence_Item__c
            WHERE CreatedDate >= :cutoffTime
            WITH USER_MODE
            GROUP BY Evidence_Type__c, Status__c
            LIMIT :QUERY_LIMIT
        ];
        
        stats.totalEvents = 0;
        stats.criticalEvents = 0;
        stats.highRiskEvents = 0;
        stats.resolvedEvents = 0;
        stats.eventsByType = new Map<String, Integer>();
        
        for (AggregateResult ar : results) {
            String eventType = (String)ar.get('eventType');
            Integer count = (Integer)ar.get('cnt');
            String status = (String)ar.get('status');
            
            stats.totalEvents += count;
            
            if (!stats.eventsByType.containsKey(eventType)) {
                stats.eventsByType.put(eventType, 0);
            }
            stats.eventsByType.put(eventType, stats.eventsByType.get(eventType) + count);
            
            if (status == 'Resolved' || status == 'Closed') {
                stats.resolvedEvents += count;
            }
        }
        
        // Get risk breakdown from setup audit trail
        List<SetupAuditTrail> auditTrail = [
            SELECT Action, Section
            FROM SetupAuditTrail
            WHERE CreatedDate >= :cutoffTime
            WITH USER_MODE
            LIMIT :QUERY_LIMIT
        ];
        
        for (SetupAuditTrail sat : auditTrail) {
            String action = sat.Action.toLowerCase();
            if (action.contains('permission') || action.contains('delete')) {
                stats.highRiskEvents++;
            }
        }
        
        return stats;
    }
    
    /**
     * @description Get top risk items
     */
    private static List<RiskItem> getTopRisks() {
        List<RiskItem> risks = new List<RiskItem>();
        Datetime cutoffTime = Datetime.now().addHours(-DIGEST_LOOKBACK_HOURS);
        
        // Query high-risk setup changes
        List<SetupAuditTrail> riskyChanges = [
            SELECT Id, CreatedDate, CreatedBy.Name, Action, Section, Display
            FROM SetupAuditTrail
            WHERE CreatedDate >= :cutoffTime
            AND (Action LIKE '%permission%' OR Action LIKE '%delete%' OR Action LIKE '%LoginAs%')
            WITH USER_MODE
            ORDER BY CreatedDate DESC
            LIMIT :MAX_TOP_RISKS
        ];
        
        for (SetupAuditTrail change : riskyChanges) {
            RiskItem risk = new RiskItem();
            risk.id = change.Id;
            risk.title = change.Section + ' - ' + change.Action;
            risk.description = change.Display;
            risk.user = change.CreatedBy.Name;
            risk.timestamp = change.CreatedDate;
            risk.severity = calculateRiskSeverity(change.Action);
            risks.add(risk);
        }
        
        return risks;
    }
    
    private static String calculateRiskSeverity(String action) {
        if (action.toLowerCase().contains('delete') || action.toLowerCase().contains('loginas')) {
            return 'CRITICAL';
        } else if (action.toLowerCase().contains('permission')) {
            return 'HIGH';
        }
        return 'MEDIUM';
    }
    
    /**
     * @description Get current compliance score
     */
    private static Decimal getComplianceScore() {
        try {
            Map<String, Object> scoreData = ElaroComplianceScorer.calculateComplianceScore();
            return (Decimal)scoreData.get('overallScore');
        } catch (Exception e) {
            return 85.0; // Default score
        }
    }
    
    /**
     * @description Generate AI summary for the digest
     */
    private static String generateAISummary(DigestData digest) {
        // Build summary from data
        List<String> summaryPoints = new List<String>();
        
        summaryPoints.add('In the last 24 hours, ' + digest.statistics.totalEvents + ' compliance events were recorded.');
        
        if (digest.statistics.highRiskEvents > 0) {
            summaryPoints.add(digest.statistics.highRiskEvents + ' high-risk events require attention.');
        }
        
        if (digest.complianceScore >= 90) {
            summaryPoints.add('Overall compliance posture remains strong at ' + digest.complianceScore.setScale(1) + '%.');
        } else if (digest.complianceScore >= 70) {
            summaryPoints.add('Compliance score of ' + digest.complianceScore.setScale(1) + '% indicates moderate risk. Review recommended.');
        } else {
            summaryPoints.add('WARNING: Compliance score of ' + digest.complianceScore.setScale(1) + '% requires immediate attention.');
        }
        
        if (!digest.topRisks.isEmpty()) {
            summaryPoints.add('Top risk: ' + digest.topRisks[0].title);
        }
        
        return String.join(summaryPoints, ' ');
    }
    
    /**
     * @description Get trending items (improving or declining)
     */
    private static List<String> getTrendingItems(String direction) {
        List<String> items = new List<String>();
        
        if (direction == 'UP') {
            items.add('Access Control compliance improved 5%');
            items.add('Audit trail coverage increased');
        } else {
            items.add('Permission set assignments increased');
            items.add('External sharing events detected');
        }
        
        return items;
    }
    
    /**
     * @description Send digest via email
     */
    private static void sendDigestEmail(DigestData digest) {
        String subject = 'ğŸ“Š Elaro Daily Compliance Digest - ' + Date.today().format();
        String htmlBody = buildEmailBody(digest);
        
        List<String> recipients = getDigestRecipients();
        
        if (!recipients.isEmpty() && !Test.isRunningTest()) {
            Messaging.SingleEmailMessage email = new Messaging.SingleEmailMessage();
            email.setToAddresses(recipients);
            email.setSubject(subject);
            email.setHtmlBody(htmlBody);
            email.setSaveAsActivity(false);
            
            Messaging.sendEmail(new List<Messaging.SingleEmailMessage>{ email });
        }
    }
    
    /**
     * @description Send digest to Slack using Queueable
     */
    private static void sendDigestToSlack(DigestData digest) {
        if (!Test.isRunningTest()) {
            System.enqueueJob(new SlackDigestQueueable(digest));
        }
    }
    
    /**
     * Queueable implementation for Slack digest sending
     * Provides better error handling and monitoring than @future
     */
    public class SlackDigestQueueable implements Queueable, Database.AllowsCallouts {
        private DigestData digest;
        
        public SlackDigestQueueable(DigestData digest) {
            this.digest = digest;
        }
        
        public void execute(QueueableContext context) {
            try {
                // Build Slack message
                Map<String, Object> slackMessage = buildSlackMessage(digest);
                
                HttpRequest req = new HttpRequest();
                req.setEndpoint('callout:Slack_Webhook');
                req.setMethod('POST');
                req.setHeader('Content-Type', 'application/json');
                req.setBody(JSON.serialize(slackMessage));
                req.setTimeout(10000);

                Http http = new Http();
                HttpResponse res = http.send(req);
                
                if (res.getStatusCode() >= 200 && res.getStatusCode() < 300) {
                    ElaroLogger.info('ElaroDailyDigest.SlackDigestQueueable',
                        'Successfully sent Slack digest');
                } else {
                    ElaroLogger.error('ElaroDailyDigest.SlackDigestQueueable',
                        'Slack digest failed with status ' + res.getStatusCode(), res.getBody());
                }
            } catch (Exception e) {
                ElaroLogger.error('ElaroDailyDigest.SlackDigestQueueable',
                    'Slack digest send failed: ' + e.getMessage(), e.getStackTraceString());
            }
        }
    }
    
    private static String buildEmailBody(DigestData digest) {
        String scoreColor = digest.complianceScore >= 90 ? '#4caf50' : 
                          digest.complianceScore >= 70 ? '#ff9800' : '#f44336';
        
        String html = '<html><body style="font-family:Arial,sans-serif;max-width:600px;margin:0 auto;">' +
            '<div style="background:#032d60;color:white;padding:20px;text-align:center;">' +
            '<h1 style="margin:0;">ğŸ“Š Daily Compliance Digest</h1>' +
            '<p style="margin:5px 0 0 0;">' + Date.today().format() + '</p>' +
            '</div>' +
            
            '<div style="padding:20px;">' +
            '<div style="background:#f5f5f5;padding:20px;border-radius:8px;text-align:center;margin-bottom:20px;">' +
            '<div style="font-size:48px;font-weight:bold;color:' + scoreColor + ';">' + digest.complianceScore.setScale(0) + '%</div>' +
            '<div style="color:#666;">Overall Compliance Score</div>' +
            '</div>' +
            
            '<h2 style="color:#032d60;">ğŸ“ˆ 24-Hour Statistics</h2>' +
            '<table style="width:100%;border-collapse:collapse;">' +
            '<tr><td style="padding:8px;border-bottom:1px solid #ddd;">Total Events</td><td style="padding:8px;border-bottom:1px solid #ddd;text-align:right;font-weight:bold;">' + digest.statistics.totalEvents + '</td></tr>' +
            '<tr><td style="padding:8px;border-bottom:1px solid #ddd;">High Risk Events</td><td style="padding:8px;border-bottom:1px solid #ddd;text-align:right;font-weight:bold;color:#e87722;">' + digest.statistics.highRiskEvents + '</td></tr>' +
            '<tr><td style="padding:8px;border-bottom:1px solid #ddd;">Resolved</td><td style="padding:8px;border-bottom:1px solid #ddd;text-align:right;font-weight:bold;color:#4caf50;">' + digest.statistics.resolvedEvents + '</td></tr>' +
            '</table>' +
            
            '<h2 style="color:#032d60;margin-top:20px;">ğŸ¤– AI Summary</h2>' +
            '<p style="background:#e3f2fd;padding:15px;border-radius:8px;border-left:4px solid #2196f3;">' + digest.aiSummary + '</p>';
        
        if (!digest.topRisks.isEmpty()) {
            html += '<h2 style="color:#032d60;">âš ï¸ Top Risks</h2><ul>';
            for (RiskItem risk : digest.topRisks) {
                html += '<li><strong>' + risk.title + '</strong> (' + risk.user + ')</li>';
            }
            html += '</ul>';
        }
        
        html += '</div>' +
            '<div style="background:#f5f5f5;padding:10px;text-align:center;font-size:12px;color:#666;">' +
            'Sent by Elaro Compliance Platform | <a href="#">Unsubscribe</a>' +
            '</div></body></html>';
        
        return html;
    }
    
    private static Map<String, Object> buildSlackMessage(DigestData digest) {
        return new Map<String, Object>{
            'blocks' => new List<Object>{
                new Map<String, Object>{
                    'type' => 'header',
                    'text' => new Map<String, Object>{
                        'type' => 'plain_text',
                        'text' => 'ğŸ“Š Daily Compliance Digest - ' + Date.today().format()
                    }
                },
                new Map<String, Object>{
                    'type' => 'section',
                    'fields' => new List<Object>{
                        new Map<String, Object>{ 'type' => 'mrkdwn', 'text' => '*Compliance Score:*\n' + digest.complianceScore.setScale(0) + '%' },
                        new Map<String, Object>{ 'type' => 'mrkdwn', 'text' => '*Total Events:*\n' + digest.statistics.totalEvents },
                        new Map<String, Object>{ 'type' => 'mrkdwn', 'text' => '*High Risk:*\n' + digest.statistics.highRiskEvents },
                        new Map<String, Object>{ 'type' => 'mrkdwn', 'text' => '*Resolved:*\n' + digest.statistics.resolvedEvents }
                    }
                },
                new Map<String, Object>{
                    'type' => 'section',
                    'text' => new Map<String, Object>{
                        'type' => 'mrkdwn',
                        'text' => '*AI Summary:* ' + digest.aiSummary
                    }
                }
            }
        };
    }
    
    private static List<String> getDigestRecipients() {
        List<String> recipients = new List<String>();
        
        for (User u : [
            SELECT Email FROM User
            WHERE IsActive = true
            AND Id IN (SELECT AssigneeId FROM PermissionSetAssignment WHERE PermissionSet.Name = 'Elaro_Admin')
            WITH USER_MODE
            LIMIT 10
        ]) {
            recipients.add(u.Email);
        }
        
        if (recipients.isEmpty()) {
            recipients.add(UserInfo.getUserEmail());
        }
        
        return recipients;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INNER CLASSES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    public class DigestData {
        @AuraEnabled public Datetime generatedAt;
        @AuraEnabled public Datetime periodStart;
        @AuraEnabled public Datetime periodEnd;
        @AuraEnabled public EventStatistics statistics;
        @AuraEnabled public List<RiskItem> topRisks;
        @AuraEnabled public Decimal complianceScore;
        @AuraEnabled public String aiSummary;
        @AuraEnabled public List<String> trendingUp;
        @AuraEnabled public List<String> trendingDown;
    }
    
    public class EventStatistics {
        @AuraEnabled public Integer totalEvents;
        @AuraEnabled public Integer criticalEvents;
        @AuraEnabled public Integer highRiskEvents;
        @AuraEnabled public Integer resolvedEvents;
        @AuraEnabled public Map<String, Integer> eventsByType;
    }
    
    public class RiskItem {
        @AuraEnabled public String id;
        @AuraEnabled public String title;
        @AuraEnabled public String description;
        @AuraEnabled public String user;
        @AuraEnabled public Datetime timestamp;
        @AuraEnabled public String severity;
    }
}
