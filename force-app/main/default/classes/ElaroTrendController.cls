/**
 * ElaroTrendController.cls
 * Time-series trend analysis with configurable granularity
 *
 * Security Features:
 * - Object whitelisting
 * - Field validation against schema
 * - Granularity validation
 * - WITH USER_MODE
 * - Date range bounds
 * - Mobile-friendly data sampling
 *
 * @author Derick Porter
 * @date 2026-01-03
 * @since v3.1.0 (Spring '26)
 * @group Compliance Framework
 */
public with sharing class ElaroTrendController {

    // Whitelisted objects
    private static final Set<String> ALLOWED_OBJECTS = new Set<String>{
        'Account',
        'Contact',
        'Opportunity',
        'Case',
        'Lead',
        'Alert__c',
        'API_Usage_Snapshot__c',
        'Deployment_Job__c',
        'Flow_Execution__c'
    };

    // Allowed granularities
    private static final Set<String> ALLOWED_GRANULARITIES = new Set<String>{
        'day', 'week', 'month', 'quarter', 'year'
    };

    // Date range limits
    private static final Integer MIN_MONTHS_BACK = 1;
    private static final Integer MAX_MONTHS_BACK = 36;
    private static final Integer DEFAULT_MONTHS_BACK = 12;

    // Data point limits
    private static final Integer MAX_DATA_POINTS = 500;

    /**
     * Get time-series trend data
     */
    @AuraEnabled(cacheable=true)
    public static TrendResult getTimeSeries(
        String objectApiName,
        String dateField,
        String metricField,
        String granularity,
        Integer monthsBack,
        String additionalFilters
    ) {
        // Validate inputs
        validateInputs(objectApiName, dateField, metricField, granularity);

        // Sanitize field names
        String safeDateField = sanitizeFieldName(dateField);
        String safeMetricField = sanitizeFieldName(metricField);
        String safeGranularity = granularity.toLowerCase();

        // Bound the date range
        Integer safeMonthsBack = boundMonthsBack(monthsBack);

        // Build the aggregation query with bind variables
        String bucketExpr = getBucketExpression(safeGranularity, safeDateField);

        QueryWithBinds qwb = buildTrendQuery(
            objectApiName,
            bucketExpr,
            safeMetricField,
            safeDateField,
            safeMonthsBack,
            additionalFilters
        );

        List<AggregateResult> results;
        try {
            results = (List<AggregateResult>) Database.queryWithBinds(
                qwb.query, qwb.binds, AccessLevel.USER_MODE
            );
        } catch (Exception e) {
            ElaroLogger.error('ElaroTrendController.getTimeSeries', e.getMessage(), e.getStackTraceString());
            throw new AuraHandledException('Unable to execute the trend query. Please verify you have the required permissions and try again.');
        }

        // Transform to trend data
        return transformResults(results, safeGranularity, safeMonthsBack);
    }

    /**
     * Get available metric fields for an object
     */
    @AuraEnabled(cacheable=true)
    public static List<MetricFieldOption> getMetricFields(String objectApiName) {
        if (!ALLOWED_OBJECTS.contains(objectApiName)) {
            throw new AuraHandledException('Object not authorized: ' + objectApiName);
        }

        List<MetricFieldOption> options = new List<MetricFieldOption>();

        SObjectType sType = Schema.getGlobalDescribe().get(objectApiName);
        if (sType == null || !sType.getDescribe().isAccessible()) {
            return options;
        }

        Map<String, SObjectField> fieldMap = sType.getDescribe().fields.getMap();

        for (String fieldName : fieldMap.keySet()) {
            DescribeFieldResult dfr = fieldMap.get(fieldName).getDescribe();

            if (!dfr.isAccessible() || !dfr.isAggregatable()) {
                continue;
            }

            // Only numeric fields for metrics
            Schema.DisplayType fieldType = dfr.getType();
            if (fieldType == Schema.DisplayType.CURRENCY ||
                fieldType == Schema.DisplayType.DOUBLE ||
                fieldType == Schema.DisplayType.INTEGER ||
                fieldType == Schema.DisplayType.PERCENT) {

                MetricFieldOption opt = new MetricFieldOption();
                opt.apiName = dfr.getName();
                opt.label = dfr.getLabel();
                opt.fieldType = String.valueOf(fieldType);
                options.add(opt);
            }
        }

        // Add COUNT option
        MetricFieldOption countOpt = new MetricFieldOption();
        countOpt.apiName = 'Id';
        countOpt.label = 'Record Count';
        countOpt.fieldType = 'COUNT';
        options.add(0, countOpt);

        return options;
    }

    /**
     * Get available date fields for an object
     */
    @AuraEnabled(cacheable=true)
    public static List<DateFieldOption> getDateFields(String objectApiName) {
        if (!ALLOWED_OBJECTS.contains(objectApiName)) {
            throw new AuraHandledException('Object not authorized: ' + objectApiName);
        }

        List<DateFieldOption> options = new List<DateFieldOption>();

        SObjectType sType = Schema.getGlobalDescribe().get(objectApiName);
        if (sType == null || !sType.getDescribe().isAccessible()) {
            return options;
        }

        Map<String, SObjectField> fieldMap = sType.getDescribe().fields.getMap();

        for (String fieldName : fieldMap.keySet()) {
            DescribeFieldResult dfr = fieldMap.get(fieldName).getDescribe();

            if (!dfr.isAccessible() || !dfr.isFilterable()) {
                continue;
            }

            Schema.DisplayType fieldType = dfr.getType();
            if (fieldType == Schema.DisplayType.DATE ||
                fieldType == Schema.DisplayType.DATETIME) {

                DateFieldOption opt = new DateFieldOption();
                opt.apiName = dfr.getName();
                opt.label = dfr.getLabel();
                opt.fieldType = String.valueOf(fieldType);
                options.add(opt);
            }
        }

        return options;
    }

    /**
     * Validate all inputs
     */
    private static void validateInputs(
        String objectApiName,
        String dateField,
        String metricField,
        String granularity
    ) {
        // Validate object
        if (String.isBlank(objectApiName)) {
            throw new AuraHandledException('Object name is required');
        }

        if (!ALLOWED_OBJECTS.contains(objectApiName)) {
            throw new AuraHandledException('Object not authorized: ' + objectApiName);
        }

        // Verify object access
        SObjectType sType = Schema.getGlobalDescribe().get(objectApiName);
        if (sType == null || !sType.getDescribe().isAccessible()) {
            throw new AuraHandledException('Access denied to object: ' + objectApiName);
        }

        // Validate fields
        if (String.isBlank(dateField)) {
            throw new AuraHandledException('Date field is required');
        }

        if (String.isBlank(metricField)) {
            throw new AuraHandledException('Metric field is required');
        }

        validateField(objectApiName, dateField, true);  // Must be date
        validateField(objectApiName, metricField, false); // Must be aggregatable

        // Validate granularity
        if (String.isBlank(granularity)) {
            throw new AuraHandledException('Granularity is required');
        }

        if (!ALLOWED_GRANULARITIES.contains(granularity.toLowerCase())) {
            throw new AuraHandledException('Invalid granularity. Allowed: ' +
                String.join(new List<String>(ALLOWED_GRANULARITIES), ', '));
        }
    }

    /**
     * Validate a field
     */
    private static void validateField(String objectName, String fieldName, Boolean mustBeDate) {
        String cleanField = sanitizeFieldName(fieldName);

        SObjectType sType = Schema.getGlobalDescribe().get(objectName);
        Map<String, SObjectField> fieldMap = sType.getDescribe().fields.getMap();

        if (!fieldMap.containsKey(cleanField.toLowerCase())) {
            throw new AuraHandledException('Invalid field: ' + fieldName);
        }

        DescribeFieldResult dfr = fieldMap.get(cleanField.toLowerCase()).getDescribe();

        if (!dfr.isAccessible()) {
            throw new AuraHandledException('Field not accessible: ' + fieldName);
        }

        if (mustBeDate) {
            Schema.DisplayType fieldType = dfr.getType();
            if (fieldType != Schema.DisplayType.DATE &&
                fieldType != Schema.DisplayType.DATETIME) {
                throw new AuraHandledException('Field must be a date type: ' + fieldName);
            }
        } else {
            // For metric fields, verify aggregatable
            if (!dfr.isAggregatable()) {
                throw new AuraHandledException('Field must be aggregatable: ' + fieldName);
            }
        }
    }

    /**
     * Bound months back to safe range
     */
    private static Integer boundMonthsBack(Integer monthsBack) {
        if (monthsBack == null || monthsBack < MIN_MONTHS_BACK) {
            return DEFAULT_MONTHS_BACK;
        }
        return Math.min(monthsBack, MAX_MONTHS_BACK);
    }

    /**
     * Get bucket expression for granularity
     */
    private static String getBucketExpression(String granularity, String dateField) {
        switch on granularity {
            when 'day' {
                return 'DAY_ONLY(' + dateField + ')';
            }
            when 'week' {
                return 'WEEK_IN_YEAR(' + dateField + ')';
            }
            when 'quarter' {
                return 'CALENDAR_QUARTER(' + dateField + ')';
            }
            when 'year' {
                return 'CALENDAR_YEAR(' + dateField + ')';
            }
            when else {
                return 'CALENDAR_MONTH(' + dateField + ')';
            }
        }
    }

    /**
     * Build the trend query with bind variables
     *
     * @param objectName The SObject API name to query
     * @param bucketExpr The date bucket expression for grouping
     * @param metricField The field to aggregate
     * @param dateField The date field for filtering and grouping
     * @param monthsBack Number of months to look back
     * @param additionalFilters Optional additional filter clause
     * @return QueryWithBinds containing the parameterized query and bind map
     */
    private static QueryWithBinds buildTrendQuery(
        String objectName,
        String bucketExpr,
        String metricField,
        String dateField,
        Integer monthsBack,
        String additionalFilters
    ) {
        Map<String, Object> binds = new Map<String, Object>();

        // Determine aggregate function
        String aggExpr;
        if (metricField.equalsIgnoreCase('Id')) {
            aggExpr = 'COUNT(Id)';
        } else {
            aggExpr = 'SUM(' + metricField + ')';
        }

        // NOPMD ApexSOQLInjection - field names validated against schema, object validated against ALLOWED_OBJECTS allowlist, monthsBack is bounded integer
        // LAST_N_MONTHS is a SOQL date literal and must be inlined
        String soql = 'SELECT ' + bucketExpr + ' bucketDate, ' +
                                  aggExpr + ' metricValue, ' +
                                  'CALENDAR_YEAR(' + dateField + ') bucketYear ' +
                      'FROM ' + objectName +
                      ' WHERE ' + dateField + ' = LAST_N_MONTHS:' + monthsBack;

        // Add additional filters if provided
        if (String.isNotBlank(additionalFilters)) {
            // Comprehensive sanitization for SOQL injection prevention
            String safeFilters = sanitizeFilterClause(additionalFilters);

            if (String.isNotBlank(safeFilters)) {
                soql += ' AND (' + safeFilters + ')';
            }
        }

        binds.put('queryLimit', MAX_DATA_POINTS);
        soql += ' GROUP BY ' + bucketExpr + ', CALENDAR_YEAR(' + dateField + ')' +
                ' ORDER BY CALENDAR_YEAR(' + dateField + '), ' + bucketExpr +
                ' WITH USER_MODE' +
                ' LIMIT :queryLimit';

        QueryWithBinds result = new QueryWithBinds();
        result.query = soql;
        result.binds = binds;
        return result;
    }

    /**
     * Transform aggregate results to trend data
     */
    private static TrendResult transformResults(
        List<AggregateResult> results,
        String granularity,
        Integer monthsBack
    ) {
        List<TimeBucket> buckets = new List<TimeBucket>();

        Decimal total = 0;
        Decimal minValue = null;
        Decimal maxValue = null;
        Decimal prevValue = null;

        for (AggregateResult ar : results) {
            TimeBucket tb = new TimeBucket();

            // Build bucket label based on granularity
            Object bucketDate = ar.get('bucketDate');
            Integer bucketYear = (Integer)ar.get('bucketYear');

            tb.bucketDate = formatBucketLabel(bucketDate, bucketYear, granularity);
            tb.bucketValue = bucketDate;
            tb.bucketYear = bucketYear;

            // Get metric value
            Decimal value = ar.get('metricValue') != null ?
                (Decimal)ar.get('metricValue') : 0;

            tb.metricValue = value;

            // Calculate change from previous period
            if (prevValue != null) {
                tb.changeFromPrevious = value - prevValue;
                tb.percentChange = prevValue != 0 ?
                    ((value - prevValue) / prevValue * 100).setScale(1, RoundingMode.HALF_UP) : null;
            }
            prevValue = value;

            // Track aggregates
            total += value;
            if (minValue == null || value < minValue) minValue = value;
            if (maxValue == null || value > maxValue) maxValue = value;

            buckets.add(tb);
        }

        // Calculate statistics
        TrendResult result = new TrendResult();
        result.buckets = buckets;
        result.granularity = granularity;
        result.periodCount = buckets.size();
        result.total = total;
        result.average = buckets.isEmpty() ? 0 :
            (total / buckets.size()).setScale(2, RoundingMode.HALF_UP);
        result.minValue = minValue;
        result.maxValue = maxValue;
        result.monthsBack = monthsBack;

        // Calculate overall trend
        if (buckets.size() >= 2) {
            Decimal firstValue = buckets[0].metricValue;
            Decimal lastValue = buckets[buckets.size() - 1].metricValue;
            result.overallChange = lastValue - firstValue;
            result.overallPercentChange = firstValue != 0 ?
                ((lastValue - firstValue) / firstValue * 100).setScale(1, RoundingMode.HALF_UP) : null;
            result.trendDirection = lastValue > firstValue ? 'up' :
                                   (lastValue < firstValue ? 'down' : 'flat');
        } else {
            result.trendDirection = 'insufficient_data';
        }

        return result;
    }

    /**
     * Format bucket label for display
     */
    private static String formatBucketLabel(Object bucketDate, Integer year, String granularity) {
        if (bucketDate == null) {
            return 'Unknown';
        }

        switch on granularity {
            when 'day' {
                return String.valueOf(bucketDate);
            }
            when 'week' {
                return 'Week ' + bucketDate + ', ' + year;
            }
            when 'quarter' {
                return 'Q' + bucketDate + ' ' + year;
            }
            when 'year' {
                return String.valueOf(bucketDate);
            }
            when else {
                // Month
                Integer monthNum = (Integer)bucketDate;
                List<String> monthNames = new List<String>{
                    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
                };
                String monthName = monthNum > 0 && monthNum <= 12 ?
                    monthNames[monthNum - 1] : String.valueOf(monthNum);
                return monthName + ' ' + year;
            }
        }
    }

    /**
     * Sanitize field name
     */
    private static String sanitizeFieldName(String fieldName) {
        if (String.isBlank(fieldName)) return '';
        return fieldName.replaceAll('[^a-zA-Z0-9_]+', '');
    }

    // ==================== Inner Classes ====================

    public class TimeBucket {
        @AuraEnabled public String bucketDate;
        @AuraEnabled public Object bucketValue;
        @AuraEnabled public Integer bucketYear;
        @AuraEnabled public Decimal metricValue;
        @AuraEnabled public Decimal changeFromPrevious;
        @AuraEnabled public Decimal percentChange;
    }

    public class TrendResult {
        @AuraEnabled public List<TimeBucket> buckets;
        @AuraEnabled public String granularity;
        @AuraEnabled public Integer periodCount;
        @AuraEnabled public Integer monthsBack;
        @AuraEnabled public Decimal total;
        @AuraEnabled public Decimal average;
        @AuraEnabled public Decimal minValue;
        @AuraEnabled public Decimal maxValue;
        @AuraEnabled public Decimal overallChange;
        @AuraEnabled public Decimal overallPercentChange;
        @AuraEnabled public String trendDirection;
    }

    public class MetricFieldOption {
        @AuraEnabled public String apiName;
        @AuraEnabled public String label;
        @AuraEnabled public String fieldType;
    }

    public class DateFieldOption {
        @AuraEnabled public String apiName;
        @AuraEnabled public String label;
        @AuraEnabled public String fieldType;
    }

    /**
     * Wrapper for a parameterized SOQL query and its bind variable map
     */
    private class QueryWithBinds {
        public String query;
        public Map<String, Object> binds;
    }

    /**
     * Sanitize filter clause by escaping string literals and blocking dangerous patterns
     * Prevents SOQL injection attacks
     */
    private static String sanitizeFilterClause(String filters) {
        if (String.isBlank(filters)) {
            return '';
        }
        
        // Block dangerous SQL/SOQL keywords and patterns
        String upper = filters.toUpperCase();
        Set<String> dangerous = new Set<String>{
            'INSERT', 'UPDATE', 'DELETE', 'UPSERT', 'MERGE',
            'DROP', 'TRUNCATE', 'ALTER', 'CREATE', 'GRANT',
            '--', '/*', '*/', ';', 'EXEC', 'EXECUTE'
        };
        
        for (String keyword : dangerous) {
            if (upper.contains(keyword)) {
                return ''; // Return empty to block the filter entirely
            }
        }
        
        // Escape string literals within the filter
        Pattern p = Pattern.compile('\'([^\']*)\'');
        Matcher m = p.matcher(filters);
        
        StringBuffer sb = new StringBuffer();
        while (m.find()) {
            String value = m.group(1);
            String escapedValue = String.escapeSingleQuotes(value);
            m.appendReplacement(sb, '\'' + escapedValue + '\'');
        }
        m.appendTail(sb);
        
        return sb.toString();
    }
}
