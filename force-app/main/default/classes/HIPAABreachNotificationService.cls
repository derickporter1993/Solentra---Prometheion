/**
 * HIPAABreachNotificationService
 *
 * Breach notification per HIPAA (45 CFR 164.400-164.414).
 * Handles breach assessment, 4-factor risk analysis, notification tracking,
 * and compliance with 60-day notification deadlines.
 *
 * @author Prometheion
 * @version 1.0
 */
public with sharing class HIPAABreachNotificationService extends ComplianceServiceBase implements IBreachNotificationService {

    private static final Integer NOTIFICATION_DEADLINE_DAYS = 60;
    private static final Integer HHS_ANNUAL_THRESHOLD = 500;

    /**
     * Get framework name
     */
    public override String getFrameworkName() {
        return 'HIPAA';
    }

    /**
     * Get framework score multiplier
     */
    protected override Decimal getFrameworkMultiplier() {
        return 0.95;
    }

    /**
     * Evaluate breach notification controls
     */
    protected override List<ComplianceServiceBase.InternalViolation> evaluateControls() {
        List<ComplianceServiceBase.InternalViolation> violations = new List<ComplianceServiceBase.InternalViolation>();

        // Check for overdue notifications
        List<HIPAA_Breach__c> overdueBreaches = getOverdueNotifications();
        for (HIPAA_Breach__c breach : overdueBreaches) {
            ComplianceServiceBase.InternalViolation violation = new ComplianceServiceBase.InternalViolation(
                'Overdue Breach Notification',
                'Breach ' + breach.Name + ' has exceeded 60-day notification deadline',
                'CRITICAL',
                'HIPAA-164.404',
                'Immediately notify affected individuals and HHS',
                10.0
            );
            violations.add(violation);
        }

        // Check for breaches pending assessment
        Integer pendingCount = getPendingAssessmentCount();
        if (pendingCount > 0) {
            ComplianceServiceBase.InternalViolation violation = new ComplianceServiceBase.InternalViolation(
                'Pending Breach Assessments',
                pendingCount + ' breach(es) pending risk assessment',
                'HIGH',
                'HIPAA-164.402',
                'Complete 4-factor risk assessment for pending breaches',
                7.5
            );
            violations.add(violation);
        }

        return violations;
    }

    // ========== IBreachNotificationService Implementation ==========

    /**
     * Assess breach risk using 4-factor analysis per ยง164.402
     */
    public BreachNotificationTypes.BreachAssessment assessBreach(
        BreachNotificationTypes.BreachAssessmentRequest request
    ) {
        BreachNotificationTypes.BreachAssessment assessment =
            new BreachNotificationTypes.BreachAssessment();
        assessment.framework = 'HIPAA';

        // Calculate risk score based on request data
        Decimal riskScore = 5.0; // Base score
        
        // Adjust based on records affected
        // Use HHS_ANNUAL_THRESHOLD constant for consistency with HIPAA 45 CFR ยง164.408
        if (request.recordsAffected != null) {
            if (request.recordsAffected >= HHS_ANNUAL_THRESHOLD) {
                riskScore += 3.0;
            } else if (request.recordsAffected >= 100) {
                riskScore += 2.0;
            } else if (request.recordsAffected >= 10) {
                riskScore += 1.0;
            }
        }
        
        // Adjust based on encryption
        if (request.encryptionInPlace != null && !request.encryptionInPlace) {
            riskScore += 2.0;
        }
        
        // Adjust based on data types
        if (request.dataTypesExposed != null && !request.dataTypesExposed.isEmpty()) {
            riskScore += 1.0;
        }
        
        assessment.riskScore = Math.min(riskScore, 10.0);
        assessment.riskLevel = getRiskLevel(assessment.riskScore);
        assessment.notificationRequired = assessment.riskScore >= 3.0;
        
        // Set notification deadline if required
        if (assessment.notificationRequired && request.discoveryDate != null) {
            assessment.notificationDeadline = request.discoveryDate.addDays(NOTIFICATION_DEADLINE_DAYS);
        } else if (assessment.notificationRequired) {
            assessment.notificationDeadline = DateTime.now().addDays(NOTIFICATION_DEADLINE_DAYS);
        }
        
        // Build analysis and mitigation steps
        assessment.analysis = 'Breach assessment completed. Records affected: ' + 
            (request.recordsAffected != null ? request.recordsAffected : 0) +
            '. Encryption in place: ' + (request.encryptionInPlace != null ? request.encryptionInPlace : false);
        
        assessment.mitigationSteps = new List<String>{
            'Notify affected individuals within 60 days',
            'Document breach details and assessment',
            'Implement additional safeguards if needed'
        };
        
        // Determine notification types required per HIPAA 45 CFR ยง164.404
        // HHS (REGULATOR) notification is only required immediately for breaches affecting 500+ individuals
        // Smaller breaches are logged and reported annually to HHS, not immediately notified
        assessment.notificationTypes = new List<String>();
        if (assessment.notificationRequired) {
            assessment.notificationTypes.add('INDIVIDUAL');
            if (request.recordsAffected != null && request.recordsAffected >= HHS_ANNUAL_THRESHOLD) {
                assessment.notificationTypes.add('REGULATOR');
                assessment.notificationTypes.add('MEDIA');
            }
            // For breaches < 500 individuals, no immediate REGULATOR notification required
            // These are logged and reported in annual HHS submission
        }
        
        // Create breach record if needed
        if (assessment.notificationRequired) {
            HIPAA_Breach__c breach = new HIPAA_Breach__c(
                Description__c = request.description,
                Discovery_Date__c = request.discoveryDate != null ? request.discoveryDate.date() : Date.today(),
                Notification_Deadline__c = assessment.notificationDeadline != null ? assessment.notificationDeadline.date() : Date.today().addDays(NOTIFICATION_DEADLINE_DAYS),
                Records_Affected__c = request.recordsAffected != null ? request.recordsAffected : 0,
                Breach_Type__c = request.incidentType,
                Risk_Level__c = assessment.riskLevel,
                Status__c = 'Open',
                Notification_Required__c = true
            );
            
            PrometheionSecurityUtils.validateCRUDAccess('HIPAA_Breach__c', PrometheionSecurityUtils.DmlOperation.DML_INSERT);
            insert breach;
            assessment.breachId = breach.Id;
        }

        return assessment;
    }
    
    /**
     * Get risk level from score
     */
    private String getRiskLevel(Decimal score) {
        if (score >= 8.0) return 'CRITICAL';
        if (score >= 6.0) return 'HIGH';
        if (score >= 4.0) return 'MEDIUM';
        return 'LOW';
    }

    /**
     * Get notification status for a breach
     */
    public BreachNotificationTypes.NotificationStatus getNotificationStatus(Id breachId) {
        BreachNotificationTypes.NotificationStatus status =
            new BreachNotificationTypes.NotificationStatus();

        HIPAA_Breach__c breach = [
            SELECT Id, Name, Discovery_Date__c, Notification_Deadline__c,
                   Individuals_Notified__c, Individual_Notification_Date__c,
                   HHS_Notified__c, HHS_Notification_Date__c,
                   Media_Notified__c, Media_Notification_Date__c,
                   Records_Affected__c, Status__c
            FROM HIPAA_Breach__c
            WHERE Id = :breachId
            WITH SECURITY_ENFORCED
            LIMIT 1
        ];

        status.breachId = breach.Id;
        
        // Set deadline and calculate if deadline was met
        // Deadline is met only if required notifications were actually sent before the deadline
        if (breach.Notification_Deadline__c != null) {
            status.deadline = DateTime.newInstance(breach.Notification_Deadline__c, Time.newInstance(0, 0, 0, 0));
            
            // Check if individual notification was sent on time (required for all breaches)
            Boolean individualsNotifiedOnTime = breach.Individuals_Notified__c == true && 
                breach.Individual_Notification_Date__c != null &&
                breach.Individual_Notification_Date__c <= breach.Notification_Deadline__c;
            
            // For breaches >= 500, also check HHS notification timing
            Boolean hhsNotificationRequired = breach.Records_Affected__c != null && 
                breach.Records_Affected__c >= HHS_ANNUAL_THRESHOLD;
            Boolean hhsNotifiedOnTime = !hhsNotificationRequired || 
                (breach.HHS_Notified__c == true && 
                 breach.HHS_Notification_Date__c != null &&
                 breach.HHS_Notification_Date__c <= breach.Notification_Deadline__c);
            
            status.deadlineMet = individualsNotifiedOnTime && hhsNotifiedOnTime;
        }

        // Individual notification status
        status.individualsNotified = breach.Individuals_Notified__c == true;
        if (breach.Individual_Notification_Date__c != null) {
            status.individualsNotificationDate = DateTime.newInstance(breach.Individual_Notification_Date__c, Time.newInstance(0, 0, 0, 0));
        }
        status.individualsNotifiedCount = breach.Records_Affected__c != null ? Integer.valueOf(breach.Records_Affected__c) : 0;

        // HHS notification status (regulator = HHS for HIPAA)
        status.regulatorNotified = breach.HHS_Notified__c == true;
        if (breach.HHS_Notification_Date__c != null) {
            status.regulatorNotificationDate = DateTime.newInstance(breach.HHS_Notification_Date__c, Time.newInstance(0, 0, 0, 0));
        }

        // Media notification
        status.mediaNotified = breach.Media_Notified__c == true;
        if (breach.Media_Notification_Date__c != null) {
            status.mediaNotificationDate = DateTime.newInstance(breach.Media_Notification_Date__c, Time.newInstance(0, 0, 0, 0));
        }

        // Overall status - use conditional logic to handle null
        if (breach.Status__c != null) {
            status.overallStatus = breach.Status__c;
        } else {
            status.overallStatus = 'OPEN';
        }

        return status;
    }

    /**
     * Get breach summary for dashboard
     */
    public BreachNotificationTypes.BreachSummary getBreachSummary() {
        BreachNotificationTypes.BreachSummary summary =
            new BreachNotificationTypes.BreachSummary();

        Date yearStart = Date.today().addYears(-1);

        List<AggregateResult> results = [
            SELECT Status__c, COUNT(Id) cnt, SUM(Records_Affected__c) total
            FROM HIPAA_Breach__c
            WHERE Discovery_Date__c >= :yearStart
            WITH SECURITY_ENFORCED
            GROUP BY Status__c
        ];

        summary.totalBreaches = 0;
        summary.openBreaches = 0;
        summary.closedBreaches = 0;
        summary.totalAffectedIndividuals = 0;

        for (AggregateResult ar : results) {
            String status = (String) ar.get('Status__c');
            Integer count = (Integer) ar.get('cnt');
            Decimal affected = (Decimal) ar.get('total');

            summary.totalBreaches += count;
            summary.totalAffectedIndividuals += affected != null ? affected.intValue() : 0;

            if (status == 'Open' || status == 'Under Investigation') {
                summary.openBreaches += count;
            } else if (status == 'Closed') {
                summary.closedBreaches += count;
            }
        }

        // Get overdue count
        summary.overdueNotifications = [
            SELECT COUNT()
            FROM HIPAA_Breach__c
            WHERE Notification_Deadline__c < TODAY
            AND Individuals_Notified__c = false
            WITH SECURITY_ENFORCED
        ];

        // Determine HHS annual report requirement
        summary.hhsAnnualReportRequired = summary.totalAffectedIndividuals >= HHS_ANNUAL_THRESHOLD;

        return summary;
    }

    /**
     * Create breach notification record
     */
    public Id createNotification(Id breachId, String notificationType) {
        HIPAA_Breach__c breach = [
            SELECT Id, Notification_Deadline__c
            FROM HIPAA_Breach__c
            WHERE Id = :breachId
            WITH SECURITY_ENFORCED
            LIMIT 1
        ];
        
        // Update breach record based on notification type
        if (notificationType == 'INDIVIDUAL') {
            breach.Individuals_Notified__c = true;
            breach.Individual_Notification_Date__c = Date.today();
        } else if (notificationType == 'REGULATOR') {
            breach.HHS_Notified__c = true;
            breach.HHS_Notification_Date__c = Date.today();
        } else if (notificationType == 'MEDIA') {
            breach.Media_Notified__c = true;
            breach.Media_Notification_Date__c = Date.today();
        }
        
        PrometheionSecurityUtils.validateCRUDAccess('HIPAA_Breach__c', PrometheionSecurityUtils.DmlOperation.DML_UPDATE);
        update breach;
        
        logAuditEntry('HIPAA_Notification_Created', breachId, 'Created ' + notificationType + ' notification');
        return breachId;
    }
    
    /**
     * Get notification deadline for a breach
     */
    public DateTime getNotificationDeadline(Id breachId) {
        HIPAA_Breach__c breach = [
            SELECT Notification_Deadline__c
            FROM HIPAA_Breach__c
            WHERE Id = :breachId
            WITH SECURITY_ENFORCED
            LIMIT 1
        ];
        
        return breach.Notification_Deadline__c != null 
            ? DateTime.newInstance(breach.Notification_Deadline__c, Time.newInstance(0, 0, 0, 0))
            : null;
    }
    
    /**
     * Generate breach report for regulators
     */
    public Id generateBreachReport(Id breachId) {
        // This would typically generate a PDF report
        // For now, return the breach ID as a placeholder
        logAuditEntry('HIPAA_Breach_Report_Generated', breachId, 'Breach report generated');
        return breachId;
    }
    
    /**
     * Get all open breaches requiring action
     */
    public List<BreachNotificationTypes.BreachSummary> getOpenBreaches() {
        List<BreachNotificationTypes.BreachSummary> summaries = new List<BreachNotificationTypes.BreachSummary>();
        
        List<HIPAA_Breach__c> breaches = [
            SELECT Id, Name, Breach_Type__c, Risk_Level__c, Records_Affected__c,
                   Discovery_Date__c, Notification_Deadline__c, Status__c
            FROM HIPAA_Breach__c
            WHERE Status__c != 'Closed'
            WITH SECURITY_ENFORCED
            ORDER BY Notification_Deadline__c ASC NULLS LAST
        ];
        
        for (HIPAA_Breach__c breach : breaches) {
            BreachNotificationTypes.BreachSummary summary = new BreachNotificationTypes.BreachSummary();
            summary.breachId = breach.Id;
            summary.incidentType = breach.Breach_Type__c;
            summary.severity = breach.Risk_Level__c;
            summary.recordsAffected = breach.Records_Affected__c != null ? breach.Records_Affected__c.intValue() : 0;
            summary.discoveryDate = breach.Discovery_Date__c != null 
                ? DateTime.newInstance(breach.Discovery_Date__c, Time.newInstance(0, 0, 0, 0))
                : null;
            summary.notificationDeadline = breach.Notification_Deadline__c != null
                ? DateTime.newInstance(breach.Notification_Deadline__c, Time.newInstance(0, 0, 0, 0))
                : null;
            summary.status = breach.Status__c;
            summary.framework = 'HIPAA';
            summary.riskScore = 0.0; // Would need to calculate from breach data
            summaries.add(summary);
        }
        
        return summaries;
    }
    
    /**
     * Get breach metrics for reporting
     */
    public BreachNotificationTypes.BreachMetrics getBreachMetrics(Integer days) {
        BreachNotificationTypes.BreachMetrics metrics =
            new BreachNotificationTypes.BreachMetrics();

        Date startDate = Date.today().addDays(-days);

        List<HIPAA_Breach__c> breaches = [
            SELECT Id, Discovery_Date__c, Individual_Notification_Date__c,
                   Records_Affected__c, Risk_Level__c, Breach_Type__c
            FROM HIPAA_Breach__c
            WHERE Discovery_Date__c >= :startDate
            WITH SECURITY_ENFORCED
        ];

        metrics.totalBreaches = breaches.size();
        metrics.breachesByType = new Map<String, Integer>();
        metrics.breachesBySeverity = new Map<String, Integer>();
        metrics.averageResolutionDays = 0;

        Decimal totalNotificationDays = 0;
        Integer notifiedCount = 0;

        for (HIPAA_Breach__c breach : breaches) {
            // Count by type
            String breachType = breach.Breach_Type__c != null ? breach.Breach_Type__c : 'Unknown';
            if (!metrics.breachesByType.containsKey(breachType)) {
                metrics.breachesByType.put(breachType, 0);
            }
            metrics.breachesByType.put(breachType, metrics.breachesByType.get(breachType) + 1);

            // Count by severity (using Risk_Level__c field)
            String severity = breach.Risk_Level__c != null ? breach.Risk_Level__c : 'Unknown';
            if (!metrics.breachesBySeverity.containsKey(severity)) {
                metrics.breachesBySeverity.put(severity, 0);
            }
            metrics.breachesBySeverity.put(severity, metrics.breachesBySeverity.get(severity) + 1);

            // Calculate notification time
            if (breach.Individual_Notification_Date__c != null && breach.Discovery_Date__c != null) {
                totalNotificationDays += breach.Discovery_Date__c.daysBetween(
                    breach.Individual_Notification_Date__c
                );
                notifiedCount++;
            }
        }

        if (notifiedCount > 0) {
            metrics.averageResolutionDays = (totalNotificationDays / notifiedCount).setScale(1);
        }

        return metrics;
    }

    // ========== Aura-Enabled Methods ==========

    /**
     * Create new breach record
     */
    @AuraEnabled
    public static Id createBreachRecord(Map<String, Object> breachData) {
        HIPAA_Breach__c breach = new HIPAA_Breach__c();
        breach.Description__c = (String) breachData.get('description');
        breach.Discovery_Date__c = Date.today();
        breach.Notification_Deadline__c = Date.today().addDays(NOTIFICATION_DEADLINE_DAYS);
        breach.Records_Affected__c = (Decimal) breachData.get('recordsAffected');
        breach.Breach_Type__c = (String) breachData.get('breachType');
        breach.Status__c = 'Open';

        PrometheionSecurityUtils.validateCRUDAccess('HIPAA_Breach__c', PrometheionSecurityUtils.DmlOperation.DML_INSERT);
        insert breach;

        // Log audit entry
        HIPAABreachNotificationService service = new HIPAABreachNotificationService();
        service.logAuditEntry('HIPAA_Breach_Created', breach.Id, 'HIPAA Breach record created');

        return breach.Id;
    }

    /**
     * Get breaches pending assessment
     */
    @AuraEnabled(cacheable=true)
    public static List<HIPAA_Breach__c> getPendingBreaches() {
        return [
            SELECT Id, Name, Description__c, Discovery_Date__c, Records_Affected__c,
                   Breach_Type__c, Status__c, Risk_Level__c
            FROM HIPAA_Breach__c
            WHERE Status__c = 'Pending Assessment'
            WITH SECURITY_ENFORCED
            ORDER BY Discovery_Date__c ASC
        ];
    }

    /**
     * Get breaches requiring notification
     */
    @AuraEnabled(cacheable=true)
    public static List<HIPAA_Breach__c> getBreachesRequiringNotification() {
        return [
            SELECT Id, Name, Description__c, Discovery_Date__c, Notification_Deadline__c,
                   Records_Affected__c, Risk_Level__c, Status__c,
                   Individuals_Notified__c, HHS_Notified__c, Media_Notified__c
            FROM HIPAA_Breach__c
            WHERE Notification_Required__c = true
            AND (Individuals_Notified__c = false OR HHS_Notified__c = false)
            WITH SECURITY_ENFORCED
            ORDER BY Notification_Deadline__c ASC
        ];
    }

    /**
     * Record individual notification
     */
    @AuraEnabled
    public static void recordIndividualNotification(Id breachId, Integer individualsNotified) {
        HIPAA_Breach__c breach = [
            SELECT Id, Individuals_Notified__c
            FROM HIPAA_Breach__c
            WHERE Id = :breachId
            WITH SECURITY_ENFORCED
            LIMIT 1
        ];

        breach.Individuals_Notified__c = true;
        breach.Individual_Notification_Date__c = Date.today();
        breach.Individuals_Notified_Count__c = individualsNotified;

        PrometheionSecurityUtils.validateCRUDAccess('HIPAA_Breach__c', PrometheionSecurityUtils.DmlOperation.DML_UPDATE);
        update breach;

        HIPAABreachNotificationService service = new HIPAABreachNotificationService();
        service.logAuditEntry('HIPAA_Individual_Notification', breachId,
            'Notified ' + individualsNotified + ' individuals');
    }

    /**
     * Record HHS notification
     */
    @AuraEnabled
    public static void recordHHSNotification(Id breachId, String hhsConfirmationNumber) {
        HIPAA_Breach__c breach = [
            SELECT Id, HHS_Notified__c
            FROM HIPAA_Breach__c
            WHERE Id = :breachId
            WITH SECURITY_ENFORCED
            LIMIT 1
        ];

        breach.HHS_Notified__c = true;
        breach.HHS_Notification_Date__c = Date.today();
        breach.HHS_Confirmation_Number__c = hhsConfirmationNumber;

        PrometheionSecurityUtils.validateCRUDAccess('HIPAA_Breach__c', PrometheionSecurityUtils.DmlOperation.DML_UPDATE);
        update breach;

        HIPAABreachNotificationService service = new HIPAABreachNotificationService();
        service.logAuditEntry('HIPAA_HHS_Notification', breachId,
            'HHS notified. Confirmation: ' + hhsConfirmationNumber);
    }

    /**
     * Get notification timeline for a breach
     */
    @AuraEnabled(cacheable=true)
    public static List<NotificationEvent> getNotificationTimeline(Id breachId) {
        List<NotificationEvent> timeline = new List<NotificationEvent>();

        HIPAA_Breach__c breach = [
            SELECT Id, Discovery_Date__c, Notification_Deadline__c,
                   Individual_Notification_Date__c, HHS_Notification_Date__c,
                   Media_Notification_Date__c, Records_Affected__c
            FROM HIPAA_Breach__c
            WHERE Id = :breachId
            WITH SECURITY_ENFORCED
            LIMIT 1
        ];

        // Discovery event
        timeline.add(new NotificationEvent(
            'Discovery',
            breach.Discovery_Date__c,
            'Breach discovered',
            'completed'
        ));

        // Individual notification
        timeline.add(new NotificationEvent(
            'Individual Notification',
            breach.Individual_Notification_Date__c,
            'Notify affected individuals',
            breach.Individual_Notification_Date__c != null ? 'completed' : 'pending'
        ));

        // HHS notification
        timeline.add(new NotificationEvent(
            'HHS Notification',
            breach.HHS_Notification_Date__c,
            breach.Records_Affected__c >= HHS_ANNUAL_THRESHOLD ?
                'Immediate HHS notification required (500+ records)' :
                'HHS annual log entry required',
            breach.HHS_Notification_Date__c != null ? 'completed' : 'pending'
        ));

        // Media notification if applicable
        if (breach.Records_Affected__c >= HHS_ANNUAL_THRESHOLD) {
            timeline.add(new NotificationEvent(
                'Media Notification',
                breach.Media_Notification_Date__c,
                'Notify prominent media outlets (500+ in state)',
                breach.Media_Notification_Date__c != null ? 'completed' : 'pending'
            ));
        }

        // Deadline
        timeline.add(new NotificationEvent(
            'Notification Deadline',
            breach.Notification_Deadline__c,
            '60-day notification deadline',
            Date.today() > breach.Notification_Deadline__c ? 'overdue' : 'upcoming'
        ));

        return timeline;
    }

    // ========== Private Helper Methods ==========

    private List<HIPAA_Breach__c> getOverdueNotifications() {
        return [
            SELECT Id, Name, Discovery_Date__c, Notification_Deadline__c
            FROM HIPAA_Breach__c
            WHERE Notification_Deadline__c < TODAY
            AND Individuals_Notified__c = false
            AND Notification_Required__c = true
            WITH SECURITY_ENFORCED
        ];
    }

    private Integer getPendingAssessmentCount() {
        return [
            SELECT COUNT()
            FROM HIPAA_Breach__c
            WHERE Status__c = 'Pending Assessment'
            WITH SECURITY_ENFORCED
        ];
    }

    private Decimal calculateNatureExtentScore(BreachNotificationTypes.BreachAssessmentRequest request) {
        Decimal score = 1;

        // High-risk PHI types increase score
        Set<String> highRiskTypes = new Set<String>{'SSN', 'Financial', 'Mental Health', 'Substance Abuse', 'HIV/AIDS'};
        if (request.dataTypesExposed != null) {
            for (String dataType : request.dataTypesExposed) {
                if (highRiskTypes.contains(dataType)) {
                    score += 2;
                }
            }
        }

        // Volume of records affects score (use >= HHS_ANNUAL_THRESHOLD per HIPAA 45 CFR ยง164.408)
        // Must match assessBreach() method for consistent 4-factor risk assessment
        if (request.recordsAffected != null && request.recordsAffected >= HHS_ANNUAL_THRESHOLD) {
            score += 2;
        } else if (request.recordsAffected != null && request.recordsAffected >= 100) {
            score += 1;
        }

        return Math.min(score, 10);
    }

    private Decimal calculateUnauthorizedPersonScore(BreachNotificationTypes.BreachAssessmentRequest request) {
        Decimal score = 5; // Default medium risk

        if (request.recipientAuthorized) {
            score = 2; // Lower risk if recipient is covered entity
        } else if (request.recipientType == 'Unknown' || request.recipientType == 'Criminal') {
            score = 9; // High risk for unknown or criminal recipients
        } else if (request.recipientType == 'Former Employee') {
            score = 6;
        }

        return score;
    }

    private Decimal calculateAcquisitionScore(BreachNotificationTypes.BreachAssessmentRequest request) {
        if (request.dataAcquired && request.dataViewed) {
            return 10; // Highest risk
        } else if (request.dataAcquired || request.dataViewed) {
            return 7;
        } else {
            return 3; // Lower risk if no evidence of acquisition/viewing
        }
    }

    private Decimal calculateMitigationScore(BreachNotificationTypes.BreachAssessmentRequest request) {
        Decimal score = 10; // Start at highest risk

        // Each mitigation reduces score
        if (request.mitigationsApplied != null) {
            for (String mitigation : request.mitigationsApplied) {
                if (mitigation.contains('Encryption')) {
                    score -= 3;
                } else if (mitigation.contains('Destroyed')) {
                    score -= 4;
                } else if (mitigation.contains('Agreement')) {
                    score -= 2;
                } else {
                    score -= 1;
                }
            }
        }

        return Math.max(score, 1);
    }

    // ========== Inner Classes ==========

    public class NotificationEvent {
        @AuraEnabled public String eventType;
        @AuraEnabled public Date eventDate;
        @AuraEnabled public String description;
        @AuraEnabled public String status;

        public NotificationEvent(String eventType, Date eventDate, String description, String status) {
            this.eventType = eventType;
            this.eventDate = eventDate;
            this.description = description;
            this.status = status;
        }
    }
}
